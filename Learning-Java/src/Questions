1. zu src/test/TestClass: Laut dem Buch Clean Code Seite 76, geht die funktion appendTestAnders, k�nntest erkl�ren wieso das so ist?

Antwort: Ok, es hat einige Zeit gedauert, bis ich deine Frage verstanden habe. Wie schon vorher erw�hnt, m�chte der Autor auf Seite 76 auf das Problem mit Output-Argumenten
hinweisen und zeigt dazu einzeilige Code-Fragmente, um die Problematik klar zu machen. Die Variable report im dritten Code-Fragment soll nicht ein StringBuffer sein, das
w�rde wie du bereits herausgefunden hast �berhaupt nicht funktionieren, da die Klasse StringBuffer die Methode appendFooter() nicht besitzt. Die Variable report soll
eine eigene Klasse repr�sentieren, die Report-Funktionialit�t anbietet. An dieser Klasse soll die Method appendFooter implementiert werden und diese soll den Footer zum
Report hinzuf�gen. Er ist der Meinung, der ich mich in diesem Beispiel nur anschlie�en kann, dass Output-Parameter schlecht sind, weil sie im Quellcode nicht so einfach zu
erkennen sind. Man muss also im Quellcode nachschauen, wie die Methode appendFooter deklariert bzw. sogar implementiert wurde. Das sollte unbedingt vermieden werden, weil
das deutlich zeigt, dass der Quellcode nicht gut zu lesen ist. Das ist aber wichtig, wenn man sp�ter einfach �ndeerungen vornehmen möchte. 

Ich beschreibe mal ausf�hrlicher, was der Author auf Seite 76 mit seinen sehr kurzen Beispielen aussagen m�chte.

Das Thema ist Output-Argumente und das sie im allgemeinen schlecht sind und zu unleserlichen Code f�hren. Output-Parameter sind, wenn Argumente als R�ckgabe f�r den Aufrufer
genutzt werden.

Ich versuche mal den Code, den Autor wohl gemeint haben k�nnte hier zu skizzieren.

public class ReportGenerator {

  public void appendFooter(StringBuffer report) {
      report.append("Footer");
  }
}


Quellcode 1:

  appendFooter(s);

Hier stellt er die Frage, ob dieser Einzeiler bedeutet
a) Hängt die Funktion s als Fu�zeile an etwas an ODER
b) Hängt die Funktion die Fu�zeile an s an  <-- (das w�re der Fall, wenn es ein Output-Parameter w�re)

Quellcode 2:

  public void appendFooter(StringBuffer report)

Diese Zeile soll jetzt zeigen, wie der Autor des Codes die Funktion appendFooter deklariert hat. Wie du in meinem Beispiel "ReportGenerator" oben sehen kannst, muss man 
der Funktion appendFooter eine StringBuffer-Instanz �bergeben, damit diese von der Implementierungsklasse ver�ndert werden kann. So eine Implementierung ist schon
zweilfelhat. Die Klasse StringBuffer wurde eingef�hrt, damit man einen String performant zusammenbauen kann. Den StringBuffer als M�glichkeit zu nutzen, damit eine
Funktion diese manipulieren kann, um das Ergebnis zur�ckzugeben ist definitiv nicht offensichtlich und damit �berraschend. Damit ist das schwer zu lesen und am Ende
fehleranf�llig.

Der Autor meint, dass man Output-Parameter in Java �berhaupt nicht braucht und das es die Aufgabe von this ist als Output-Parameter zu dienen. Das bedeutet man soll den
Aufruf von appendFooter so schreiben:

Quellcode 3:

  report.appendFooter();

Die L�sung, die sich der Autor w�nscht, k�nnte f�r mein obiges Beispiel dann so aussehen:

public class Report {

  private StringBuffer reportString;

  public void appendFooter() {
      reportString.append("Footer");
  }
}

Damit muss kein StringBuffer in appendFooter mehr �bergeben werden. Die Klasse "Report" �bernimmt die Speicherung des Report-Strings intern und wie in Quellcode 3 zu sehen, 
ist sofort klar, dass appendFooter einen Footer an den Report anh�ngt.

Ich hoffe, mit dieser l�ngeren Erkl�rung ist jetzt klarer, worum es dem Autor auf Seite 76 ging. Er f�hrt keine neuen Konzepte f�r den Aufruf von Funktionen/Methoden ein,
sondern versucht, auf wenige S�tze beschr�nkt den Sachverhalt von Output-Argumenten zu erkl�ren.

Wie ich bereits in meiner letzten Antwort angemerkt hatte, ist das Buch f�r Personen, die bereits Java als Programmiersprache beherrschen und ihren Programmierstil
verbessern wollen. Es ist nicht daf�r gedacht, um Java erstmal zu erlernen. Das setzt der Autor f�r das Buch bereits voraus. Deshalb sind die Erkl�rungen an vielen
Stellen kurz und knacking, weil er davon ausgeht, dass die Beispiele f�r Java-Programmierer ausreichen. 